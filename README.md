《Vue.js 设计与实现》导读
# 4.响应系统的作用与实现
## 响应系统
概念
- 副作用函数 effect 是什么？
- 什么是响应式数据？
- 什么叫可调度性？-> trigger 动作触发副作用函数重新执行时，有能力决定副作用函数执行的时机、次数以及方式  

设计一个完整的响应式系统需要解决的问题
- 在副作用函数与被操作的目标字段之间建立明确的关系 -> weakMap + Map
- 避免分支切换时可能会产生遗留的副作用函数的问题 -> Set
- 副作用函数发生嵌套时，响应式数据在外层副作用函数中读取，收集到的副作用函数也都是内层的副作用函数 -> effect 栈
- 无限递归循环导致的栈溢出 -> trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行。
- 怎么实现调度能力？-> 为 effect 添加选项参数，通过 scheduler 选项指定调度器，并通过调度器实现任务去重。

## 实现 computed
概念
- 懒执行的 effect 是什么意思？
- 实质？ -> 一个懒加载的副作用函数（通过手动方式使其执行）  

问题
- 怎么利用 lazy effect，实现懒计算？
- 怎么实现值缓存？
- 所依赖的响应式数据变化时，怎么调用副作用函数重新进行计算？-> 通过 scheduler 将 dirty 标记设置为 true（脏），下次读取计算属性的值时重新计算。
- 在另一个副作用函数中读取计算属性（不是在该副作用函数中读取计算属性的值）且计算属性所依赖的响应式数据变化时，没有触发该副作用函数的重新执行，为什么？怎么解决？
  - 原因：本质上一个典型的 effect 嵌套。一个计算属性内部拥有自己的 effect，并且它是懒执行的，只有当真正读取计算属性的值时才会执行。对于计算属性的 getter 函数来说，它里面访问的响应式数据只会把 computed 内部的 effect 收集为依赖。而当把计算属性用于另外一个 effect时，就会发生 effect 嵌套，外层的 effect 不会被内层 effect 中的响应式数据收集。
  - 解决：当读取计算属性时，手动调用 track 函数进行追踪；当计算属性依赖的响应式数据发生变化时，可以手动调用 trigger 函数触发响应。  

## 实现 watch
概念
- 在多进程或多线程中的竞态问题是什么？
- 实现原理？ -> 本质上利用了副作用函数重新执行时的可调度行。  

设计 watch 函数
- 将硬编码式的的读取操作（例如只能读取对象 a 的属性 b）封装成通用的读取操作 -> traverse 函数进行递归读取
- 怎么把 watch 函数的第一个参数从一个响应式数据变成一个 getter 函数（从观测一个响应式数据深入到接收一个自定义函数，使 watch 更强大）？->  定义 getter 来区分两种情况
- 回调函数中怎么拿到新值和旧值？-> 使用 lazy 选项 创建一个懒加载的 effect 函数的
- 怎么选择 watch 回调的执行时机 ？-> 选项参数 + 把 scheduler 调度器封装成一个通用函数
  - 立即执行 -> immediate 选项参数
  - 其他执行时机 -> flush 选项参数（本质上是利用了调度器和异步的微任务队列）
- 怎么解决过期的副作用？-> watch 的第三个参数 onInvalidate，使用 onOnvalidate 函数注册一个回调，这个回调函数在当前副作用函数过期时执行（每当 watch 的回调函数执行之前，会优先执行用户通过 onInvalidate 注册的过期回调。这样，用户就有机会在过期回调中将上一次的副作用标记为“过期”，从而解决竞态问题）

# 5.非原始值的响应式方案
概念
- 什么是代理、Proxy、Reflect？基本操作有哪些？非基本操作有哪些？
- Reflect 函数的作用？（见86～88页）
- 怎么区分一个对象是普通对象还是函数？怎么区分一个对象是普通对象还是异质对象？
- 什么是浅响应？-> 只是对象的第一层属性是响应的。  

代理 Object
- 对一个普通对象读取操作的拦截
- 访问属性的拦截 -> Proxy 构造函数中设置 get 函数来 track，
- in 操作符的拦截 -> Proxy 构造函数中设置 has 函数来 track
- for...in 循环的拦截 -> Proxy 构造函数中设置 ownKeys 函数来 track
  - 新增属性，会增加 for...in 循环次数 -> Proxy 构造函数中设置 set 函数来 track && 需要触发与 ITERATE_KEY 相关联的副作用函数重新执行 -> 完善 trigger 函数（新增 type 参数）
  - 修改属性，for...in 循环次数不变 -> Proxy 构造函数中设置 set 函数来 track && 不需要触发与 ITERATE_KEY 相关联的副作用函数重新执行 -> 完善 trigger 函数（新增 type 参数）
  - 删除属性，会减少 for...in 循环次数 -> Proxy 构造函数中设置 set 函数来 track && 需要触发与 ITERATE_KEY 相关联的副作用函数重新执行 -> 完善 trigger 函数（新增 type 参数）
- 合理地触发响应
  - 设置的值没有发生变化时，不需要触发响应（另一种说法：“设置的值发生变化时，并且都不是 NaN时，需要触发响应”）-> 完善 Proxy 构造函数中的 set 函数
  - 将 Proxy 构造函数进行封装 -> 得到组合式 API 中熟悉的 reactive 方法
  - 屏蔽由原型引起的更新 -> 确定 receiver 是不是 target 的代理对象（只有 receiver 是 target 的代理对象才更新） -> 完善 Proxy 构造函数中的get 函数（raw 属性）
- 浅响应和深响应
  - 怎么实现深响应？-> Reflect.get 返回的结果是对象，则递归地调用 reactive 函数将其包装成响应式对象，再返回 -> 完善 Proxy 构造函数中的 get 函数
  - 怎么兼顾深响应和浅响应？-> reactive 函数摇身一变成 createReactive 函数，并完善 Proxy 构造函数中的 get 函数（添加 isShallow 属性），实现深响应（reactive）和浅响应（shallowReactive）时分别调用 createReactive 函数，赋予不同的 isShallow 参数
- 只读和浅只读
  - 怎么实现只读？-> 为 createReactive 函数添加 isReadonly 属性 -> 完善 Proxy 构造函数中的 set 函数（不允许修改）和 deleteProperty（不允许删除）
