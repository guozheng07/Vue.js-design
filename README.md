《Vue.js 设计与实现》导读
# 4.响应系统的作用与实现
## 响应系统
概念
- 副作用函数 effect 是什么？
- 什么是响应式数据？
- 什么叫可调度性？-> trigger 动作触发副作用函数重新执行时，有能力决定副作用函数执行的时机、次数以及方式  

设计一个完整的响应式系统需要解决的问题
- 在副作用函数与被操作的目标字段之间建立明确的关系 -> weakMap + Map
- 避免分支切换时可能会产生遗留的副作用函数的问题 -> Set
- 副作用函数发生嵌套时，响应式数据在外层副作用函数中读取，收集到的副作用函数也都是内层的副作用函数 -> effect 栈
- 无限递归循环导致的栈溢出 -> trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行。
- 怎么实现调度能力？-> 为 effect 添加选项参数，通过 scheduler 选项指定调度器，并通过调度器实现任务去重。

## 实现 computed
概念
- 懒执行的 effect 是什么意思？
- 实质？ -> 一个懒加载的副作用函数（通过手动方式使其执行）  

问题
- 怎么利用 lazy effect，实现懒计算？
- 怎么实现值缓存？
- 所依赖的响应式数据变化时，怎么调用副作用函数重新进行计算？-> 通过 scheduler 将 dirty 标记设置为 true（脏），下次读取计算属性的值时重新计算。
- 在另一个副作用函数中读取计算属性（不是在该副作用函数中读取计算属性的值）且计算属性所依赖的响应式数据变化时，没有触发该副作用函数的重新执行，为什么？怎么解决？
  - 原因：本质上一个典型的 effect 嵌套。一个计算属性内部拥有自己的 effect，并且它是懒执行的，只有当真正读取计算属性的值时才会执行。对于计算属性的 getter 函数来说，它里面访问的响应式数据只会把 computed 内部的 effect 收集为依赖。而当把计算属性用于另外一个 effect时，就会发生 effect 嵌套，外层的 effect 不会被内层 effect 中的响应式数据收集。
  - 解决：当读取计算属性时，手动调用 track 函数进行追踪；当计算属性依赖的响应式数据发生变化时，可以手动调用 trigger 函数触发响应。  

## 实现 watch
概念
- 在多进程或多线程中的竞态问题是什么？
- 实现原理？ -> 本质上利用了副作用函数重新执行时的可调度行。  

设计 watch 函数
- 将硬编码式的的读取操作（例如只能读取对象 a 的属性 b）封装成通用的读取操作 -> traverse 函数进行递归读取
- 怎么把 watch 函数的第一个参数从一个响应式数据变成一个 getter 函数（从观测一个响应式数据深入到接收一个自定义函数，使 watch 更强大）？->  定义 getter 来区分两种情况
- 回调函数中怎么拿到新值和旧值？-> 使用 lazy 选项 创建一个懒加载的 effect 函数的
- 怎么选择 watch 回调的执行时机 ？-> 选项参数 + 把 scheduler 调度器封装成一个通用函数
  - 立即执行 -> immediate 选项参数
  - 其他执行时机 -> flush 选项参数（本质上是利用了调度器和异步的微任务队列）
- 怎么解决过期的副作用？-> watch 的第三个参数 onInvalidate，使用 onOnvalidate 函数注册一个回调，这个回调函数在当前副作用函数过期时执行（每当 watch 的回调函数执行之前，会优先执行用户通过 onInvalidate 注册的过期回调。这样，用户就有机会在过期回调中将上一次的副作用标记为“过期”，从而解决竞态问题）
